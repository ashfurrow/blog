---
title: Foresight
date: 2025-06-22
---

Imagine you are a software developer. It's the early 1970's and you make a living writing Basic Assembly Language to build sofware for the System/360 mainframe. You are great at your job and you enjoy it.

You keep hearing about new "high level" programming languages that would allow you to write code in a way that could be "compiled" to run on different kinds of computers. In theory, this would be a huge benefit over writing assembly for just one kind of computer. But there's a catch: these compilers aren't reliable. The code they produce has bugs that wouldn't have existed if a human had written the equivalent application in assembly. The code is inefficient, it is a mess to debug, and you have to use a whole new tool, a compiler. 

Compilers introduce a layer of abstraction. Another build step. Another cost. Another skill. Using a compiler would _mediate the craft of programming_, alienating a programmer from both their craft and their labour. **Compilers come with tradeoffs**. You don't really like these tradeoffs, personally, and decide to stick with BAL.

But you keep an eye on new compilers.

Over time, compilers become more reliable, more stable, more performant. There are a lot of new languages and tools and it's hard for you to know which ones to invest time into learning. (We all remember what happened to PL/I, am I right?) But you decide to learn a new language in your spare time, named C.

You have a long and prosperous career.

The End.

---

Imagine you are a software developer who considers themselves to be a moral person. It's the early 1970's and you make a living writing Basic Assembly Language to build sofware for the System/360 mainframe. You are great at your job and you enjoy it.

You keep hearing about new "high level" programming languages that would allow you to write code in a way that could be "compiled" to run on different kinds of computers. In theory, this would be a huge benefit over writing assembly for just one kind of computer. 

But there's a catch: **these compilers are cursed**. 

Compilers are conjured by programmers in dark cloaks under the cover of a new moon. It's an eldritch ceremony. No one _really_ understands how a compiler works, other than... _the cost_. Every time a programmer compiles a program, a _cost is extracted_. Every time a programmer compiles a program, someone – somewhere – suffers. Someone suffers just a little bit, and the programmer doesn't get to see it. 

(Also compilers are slow, unreliable, hard to debug, etc. All the same tradeoffs readers are familiar with, they're just _also_ cursed.) 

**Compilers come with tradeoffs**. You don't really like these tradeoffs, personally, and decide to stick with BAL.

But you keep an eye on new compilers.

Over time, compilers become more reliable, more stable, more performant. The curse remains. You see the enormous value in using a compiler, you see how much more productive you could be if you used this tool. 

You try using one compiler, and it doesn't work. You wait a while, and you try another. A new one. It _does_ work. In fact, it _exceeds your wildest expectations_.

You consider yourself a moral person. You know about the curse. You see other programmers who decline to make the switch, correctly pointing at the tradeoffs. 

"Compilers aren't worth it," they assert. "The curse is an unacceptable tradeoff! We refuse to use a compiler!"

But here's the thing. 

Programmers aren't the ones who get to decide.

Jobs in writing assembly get harder to come by. You don't expect the market for jobs will ever disappear _entirely_, but you see the industry is moving on. You see an entire new generation of programmers who have _never not_ used a compiler. 

You have bills to pay, a career to think about, and these compilers actually seem pretty fun and useful. You're actually excited about all the cool things you could build with them.

You still consider yourself a moral person. And you make a decision.
